// rasmx86_64 - ins_adder module
// -----------------------------
// made by matissoss
// licensed under MPL 2.0

const PLACEHOLDER : &'static str = 
"// rasmx86_64 - src/shr/ins_switch.rs
// ----------------------------------
// made by matissoss
// licensed under MPL 2.0
//
// WARNING: THIS CODE WAS GENERATED BY ins_adder MODULE

use crate::shr::ins::Mnemonic as Ins;
";
const NONE : &'static str = "None";
const SOME : &'static str = "Some";
const BUF  : &'static str = "rstr";

#[derive(Clone, PartialEq, Eq, Debug)]
enum Branch{
    Last(char, usize, String),
    Next(char, usize, Box<Branch>),
    Multiple(char, usize, Vec<Box<Branch>>)
}

fn main() {
    let inp = &std::env::args().collect::<Vec<String>>()[1..];

    let mut str2arr = Vec::new();
    for s in inp {
        str2arr.push(parse_instr(s.to_string()));
    }
    let mut sorted = Vec::new();
    for strarr in str2arr {
        merge(&mut sorted, dbg!(sort(strarr)));
    }
    let branches = make_branches(sorted);
    let mut final_branch = Vec::new();
    for branch in branches{
        final_branch.push((branch.0, merge_branches(branch.1)))
    }
    println!("FINAL BRANCH: {:?}\n\n---", final_branch);
    println!("{}", print_tree(final_branch));
}

fn print_tree(tree: Vec<(usize, Vec<Box<Branch>>)>) -> String{
    let mut finstr = String::from(PLACEHOLDER);
    finstr.push_str("\nfn mnem_fromstr(str: &str) -> Option<Ins> {\n");
    finstr.push_str("\tlet rstr = str.as_bytes();\n");
    finstr.push_str("\tmatch rstr.len() {\n\t\t");
    for (size, branches) in tree {
        if !branches.is_empty(){
            finstr.push_str(&format!("{size} => match {BUF}[0] {{{}}},",
                format!("{},_=>{NONE}", print_branch(branches))
            ));
        }
    }
    finstr.push_str("\n\t\t_ => None,\n\t}");
    finstr.push_str("\n}");
    finstr
}

fn print_branch(branch: Vec<Box<Branch>>) -> String{
    let mut finstr = String::new();
    for leaf in branch {
        finstr.push_str(&match *leaf {
            Branch::Multiple(c, idx, branch) => format!("b'{c}' => match {BUF}[{idx}]{{{},_ => {NONE}}}", print_branch(branch)),
            Branch::Next(c, idx, branch) => format!(
                "b'{c}' => match {BUF}[{idx}] {{ {},_ => {NONE}}}",
                print_branch(vec![branch]),
            ),
            Branch::Last(c, _, string) => format!("b'{c}' => {SOME}(Ins::{})", string.to_uppercase()),
        })
    }
    finstr
}

fn make_branches(arr: Vec<Vec<String>>) -> Vec<(usize, Vec<Box<Branch>>)>{
    let mut brancharr = Vec::new();
    for strarr in arr {
        for str in strarr {
            let len = str.len();
            if brancharr.len() <= len {
                for idx in 0..=len {
                    if brancharr.get(idx).is_none(){
                        brancharr.push((idx, Vec::new()));
                    }
                }
            }
            make_branch(&str, &mut brancharr[len].1);
        }
    }
    brancharr
}

fn merge_branch(lhs: Box<Branch>, rhs: Box<Branch>) -> Vec<Box<Branch>>{
    match (*lhs.clone(), *rhs.clone()) {
        (Branch::Next(chr, idx, branch), Branch::Next(chr1, _, branch1)) => if chr == chr1 {
            vec![Box::new(Branch::Multiple(chr, idx, merge_branch(branch, branch1)))]
        } else {
            vec![lhs, rhs]
        },
        (Branch::Last(chr, idx, str), Branch::Last(chr1, idx1, str1)) => {
            assert!(chr != chr1);
            vec![Box::new(Branch::Last(chr, idx, str)), Box::new(Branch::Last(chr1, idx1, str1))]
        },
        _ => panic!("Unexpected")
    }
}

fn branch_nextpush(charr: &[char], idx: usize, str: &String) -> Branch{
    if idx + 1 == charr.len() {
        Branch::Last(charr[idx], idx, str.clone())
    } else {
        Branch::Next(charr[idx], idx, Box::new(branch_nextpush(charr, idx + 1, str)))
    }
}

fn make_branch(str: &String, brancharr: &mut Vec<Box<Branch>>) {
    let chars = str.chars().collect::<Vec<char>>();
    brancharr.push(Box::new(branch_nextpush(&chars, 0, str)))
}

fn merge(arr: &mut Vec<Vec<String>>, arr2: Vec<Vec<String>>) {
    if arr.len() < arr2.len() {
        for i in 0..=arr2.len() {
            if arr.get(i).is_none(){
                arr.push(Vec::new());
            }
        }
    }
    for idx in 0..arr2.len() {
        arr[idx].extend(arr2[idx].clone());
    }
}

fn sort(strarr: Vec<String>) -> Vec<Vec<String>> {
    let mut arr = Vec::new();
    for str in strarr{
        if arr.get(str.len()).is_none(){
            while arr.get(str.len()).is_none(){
                arr.push(Vec::new());
            }
        }
        arr[str.len()].push(str);
    }
    arr
}

// we will use the `supported-instructions-raw` method
fn parse_instr(str: String) -> Vec<String>{
    let mut strarr = Vec::new();
    let mut tmpbuf = Vec::new();
    for byte in str.as_bytes(){
        if byte == &b'\n'{
            strarr.push(String::from_iter(tmpbuf.iter()));
            tmpbuf = Vec::new();
        }
        else {
            tmpbuf.push((*byte as char).to_ascii_lowercase());
        }
    }
    if !tmpbuf.is_empty(){
        strarr.push(String::from_iter(tmpbuf.iter()));
    }
    strarr
}

// generated btw
fn merge_branches(mut branches: Vec<Box<Branch>>) -> Vec<Box<Branch>> {
    if branches.is_empty() {
        return Vec::new();
    }
    let mut merged: Vec<Box<Branch>> = Vec::new();
    while let Some(branch) = branches.pop() {
        let mut new_merged = Vec::new();
        let mut merged_branch = Some(branch);
        for existing in merged.into_iter() {
            if let Some(b) = merged_branch.take() {
                let merged_result = merge_branch(b, existing);
                for m in merged_result {
                    new_merged.push(m);
                }
            } else {
                new_merged.push(existing);
            }
        }
        if let Some(b) = merged_branch.take() {
            new_merged.push(b);
        }
        merged = new_merged;
    }
    merged
}
